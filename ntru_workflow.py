from ntru_utils import *
from parameters import *


def keyGen(p,q,N):
    '''
    Creates Public and Private Keys.
    '''
    
    # Find f, f_p, f_q (given currently) 
    # TODO: Mechanism to select a function f s.t. fp,fq exist. 

    f = B(df)
    fp = find_inv(f,p)
    fq = find_inv(f,q)
    while f.convolution(fp)[0] != 1 or f.convolution(fp)[0] != 1:
        f = B(df)
        fp = find_inv(f,p)
        fq = find_inv(f,q)
    
    '''
    f = trunc_polynomial([-1,0,-1,0,-1,0,1,0,1,1,1]) # in L_f -> B(df)
    fp = trunc_polynomial([1,0,1,0,1,2,2,2,1,0]) # find_inv(f, p)
    fq = trunc_polynomial([45,49,26,40,53,47,21,24,60,32,31]) # find_inv(f,q)
    '''

    g = B(dg)#trunc_polynomial([-1,-1,0,-1,0,1,0,1,0,1]) # B(dg)
    h = g.convolution(fq).scale(q)

    pub_key = (N, h, p, q, df, dg, dr)
    pri_key = (f, fp)

    return pub_key, pri_key

def encrypt(msg, pub_key):
    '''
    Encrypts message utilizing the public key generated by keyGen().

    Parameters
    ----------
    msg    : np.array <int> 
    pub_key: tuple 
    '''
    N, h, p, q, df, dg, dr = pub_key
    m = trunc_polynomial(msg)
    r = B(dr) #trunc_polynomial([-1,0,1,0,0,1,-1,0,0,1]) #B(dr) 

    e = trunc_polynomial(p * r.convolution(h) + m).mod(q)
    return e

def decrypt(e, pri_key):
    '''
    Decrypts message utilizing the private key generated by keyGen().

    Parameters
    ----------
    e      : truncated polynomial (encrypted from message) 
    pub_key: tuple 
    '''
    f, fp = pri_key

    a = (f.convolution(e)).mod(q)
    
    a = a.scale(q/2, center = True)

    m = (fp.convolution(a)).mod(p)
    return m