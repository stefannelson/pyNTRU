from ntru_utils import *
from parameters import *


def keyGen(p,q,N):
    '''
    Creates Public and Private Keys.
    '''

    ones = np.zeros(N); ones[-1] = 1
    ones = trunc_poly(ones, N, a)

    # Find f, f_p, f_q  
    f = B(df)

    fp = find_inv(f,p)
    fq = find_inv(f,q)
    while (f.mult(fp, p) != ones) \
        or (f.mult(fq, q) != ones):
        f = B(df)
        fp = find_inv(f,p)
        fq = find_inv(f,q); print('fq * f:\n',f.mult(fq,q)) 

    g = B(dg) 
    h = g.mult(fq, q).scale(q) 

    pub_key = (N, h, p, q, df, dg, dr)
    pri_key = (f, fp)

    return pub_key, pri_key

def encrypt(msg, pub_key):
    '''
    Encrypts message utilizing the public key generated by keyGen().

    Parameters
    ----------
    msg    : np.array <int> 
    pub_key: tuple 
    '''
    N, h, p, q, df, dg, dr = pub_key
    m = trunc_poly(msg, N, a)
    r = B(dr) #trunc_polynomial([-1,0,1,0,0,1,-1,0,0,1]) #B(dr) 

    e = trunc_poly(p * r.mult(h, 10000) + m, N, a).mod(q)
    return e

def decrypt(e, pri_key):
    '''
    Decrypts message utilizing the private key generated by keyGen().

    Parameters
    ----------
    e      : truncated polynomial (encrypted from message) 
    pub_key: tuple 
    '''
    f, fp = pri_key

    a = f.mult(e,q)
    
    a = a.scale(q/2, center = True)

    m = fp.mult(a, p)
    return m